package com.nayaware.twproto.ui;

import org.openide.util.NbBundle;
import org.openide.windows.*;

// As needed:
/*
 import java.awt.Toolkit;
 import java.io.*;
 import java.net.*;
 import org.openide.TopManager;
 import org.openide.actions.*;
 import org.openide.awt.UndoRedo;
 import org.openide.nodes.Node;
 import org.openide.util.HelpCtx;
 import org.openide.util.actions.*;
 import org.openide.util.datatransfer.PasteType;
 import org.openide.util.io.*;
 */

/**
 * An openable window available to the IDE's window manager.
 * 
 * @author Winston Prakash
 */
public class TwHierarchyView extends TopComponent /* or CloneableTopComponent */{

	// REMEMBER: You should have a public default constructor!
	// This is for externalization. If you have a nondefault
	// constructor for normal creation of the component, leave
	// in a default constructor that will put the component into
	// a consistent but unconfigured state, and make sure readExternal
	// initializes it properly. Or, be creative with writeReplace().
	public TwHierarchyView() {
		initComponents();
		setCloseOperation(CLOSE_LAST); // or CLOSE_EACH
		// Display name of this window (not needed if you use the DataObject
		// constructor):
		// setName(NbBundle.getMessage(TwHierarchyView.class,
		// "LBL_component_name"));
		setName("Hierarchy View");
		// You may set the icon, but often it is better to set the icon for an
		// associated mode instead:
		// setIcon (Toolkit.getDefaultToolkit ().getImage (new URL
		// ("nbrescurrloc:/TwHierarchyViewIcon.gif")));
		// Use the Component Inspector to set tool-tip text. This will be saved
		// automatically. Other JComponent properties you may need to save
		// yuorself.
		// At any time you can affect the node selection:
		// setActivatedNodes (new Node[] { ... });
	}

	/*
	 * public HelpCtx getHelpCtx () { return new HelpCtx
	 * (TwHierarchyView.class); }
	 */

	/*
	 * // If you are using CloneableTopComponent, probably you should override:
	 * protected CloneableTopComponent createClonedObject () { return new
	 * TwHierarchyView (); } protected boolean closeLast () { // You might want
	 * to prompt the user first and maybe return false: return true; }
	 */

	// APPEARANCE

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the FormEditor.
	 */
	private void initComponents() {// GEN-BEGIN:initComponents
		hierarchyPanel = new javax.swing.JPanel();

		setLayout(new java.awt.BorderLayout());

		hierarchyPanel.setLayout(new java.awt.BorderLayout());

		hierarchyPanel.setPreferredSize(new java.awt.Dimension(300, 200));
		add(hierarchyPanel, java.awt.BorderLayout.CENTER);

	}// GEN-END:initComponents

	// Variables declaration - do not modify//GEN-BEGIN:variables
	private javax.swing.JPanel hierarchyPanel;
	// End of variables declaration//GEN-END:variables

	private static final long serialVersionUID = -212573508502918111L;

	// MODES AND WORKSPACES

	/*
	 * // If you want it to open in a specific mode: public static final String
	 * TwHierarchyView_MODE = "TwHierarchyView"; public void open (Workspace ws)
	 * { super.open (ws); if (ws == null) ws = TopManager.getDefault
	 * ().getWindowManager ().getCurrentWorkspace (); Mode m = ws.findMode
	 * (TwHierarchyView_MODE); if (m == null) { try { m = ws.createMode
	 * (TwHierarchyView_MODE, // code name NbBundle.getMessage
	 * (TwHierarchyView.class, "LBL_mode_name"), // display name new URL
	 * ("nbrescurrloc:/TwHierarchyViewIcon.gif")); } catch
	 * (MalformedURLException mfue) { TopManager.getDefault ().notifyException
	 * (mfue); return; } // If you want it in a specific position: //
	 * m.setBounds (...ws.getBounds ()...); } m.dockInto (this); }
	 */

	/*
	 * // If you are not specifying a mode you may wish to use: public Dimension
	 * getPreferredSize () { return ...TopManager.getDefault ().getWindowManager
	 * ().getCurrentWorkspace ().getBounds ()...; }
	 */

	/*
	 * // If you want it to open on a specific workspace: public static final
	 * String TwHierarchyView_WORKSPACE = NbBundle.getMessage
	 * (TwHierarchyView.class, "LBL_workspace_name"); public void open () {
	 * WindowManager wm = TopManager.getDefault ().getWindowManager ();
	 * Workspace ws = wm.findWorkspace (TwHierarchyView_WORKSPACE); if (ws ==
	 * null) ws = wm.createWorkspace (TwHierarchyView_WORKSPACE); open (ws);
	 * ws.activate (); }
	 */

	// PERSISTENCE

	// private static final long serialVersionUID = ...;

	/*
	 * // If you wish to keep any state between IDE restarts, put it here:
	 * public void readExternal (ObjectInput in) throws IOException,
	 * ClassNotFoundException { super.readExternal (in); setSomeState
	 * ((SomeType) in.readObject ()); } public void writeExternal (ObjectOutput
	 * out) throws IOException { super.writeExternal (out); out.writeObject
	 * (getSomeState ()); }
	 */

	/*
	 * // The above assumes that the SomeType is safely serializable, e.g.
	 * String or Date. // If it is some class of your own that might change
	 * incompatibly, use e.g.: public void readExternal (ObjectInput in) throws
	 * IOException, ClassNotFoundException { super.readExternal (in);
	 * NbMarshalledObject read = (NbMarshalledObject) in.readObject (); if (read
	 * != null) { try { setSomeState ((SomeType) read.get ()); } catch
	 * (Exception e) { e.printStackTrace (); // If the problem would make this
	 * component inconsistent, use: // throw new SafeException (e); } } } public
	 * void writeExternal (ObjectOutput out) throws IOException {
	 * super.writeExternal (out); Object toWrite; try { toWrite = new
	 * NbMarshalledObject (getSomeState ()); } catch (Exception e) {
	 * e.printStackTrace (); toWrite = null; // Again you may prefer to use: //
	 * throw new SafeException (e); } out.writeObject (toWrite); }
	 */

	/*
	 * // Use this to discard the component after restarts (make it
	 * nonpersistent): private Object readResolve () throws
	 * ObjectStreamException { return null; // If you wish to conditionally
	 * discard it, make readExternal set // or clear some flag acc. to the
	 * condition, then use: // return discardFlag ? null : this; // Singleton
	 * component using private static TwHierarchyView theInstance: // if
	 * (theInstance == null) theInstance = this; // return theInstance; }
	 */

	// ACTIONS

	/*
	 * // If you wish to have extra actions appear in the window's // popup
	 * menu, they can go here: public SystemAction[] getSystemActions () {
	 * SystemAction[] supe = super.getSystemActions (); SystemAction[] mine =
	 * new SystemAction[supe.length + 1]; System.arraycopy (supe, 0, mine, 0,
	 * supe.length); mine[supe.length] = SystemAction.get
	 * (SomeActionOfMine.class); return mine; }
	 */

	/*
	 * // Associate implementations with copying, searching, etc.: protected
	 * void componentActivated () { ((CallbackSystemAction) SystemAction.get
	 * (FindAction.class)).setActionPerformer (new ActionPerformer () { public
	 * void performAction (SystemAction action) { // search this component
	 * somehow } }); // similar for CopyAction, CutAction, DeleteAction,
	 * GotoAction, ReplaceAction, etc. // for PasteAction, use: //
	 * ((PasteAction) SystemAction.get (PasteAction.class)).setPasteTypes (new
	 * PasteType[] { ... }); } protected void componentDeactivated () {
	 * ((CallbackSystemAction) SystemAction.get
	 * (FindAction.class)).setActionPerformer (null); // ((PasteAction)
	 * SystemAction.get (PasteAction.class)).setPasteTypes (null); }
	 */

	/*
	 * // If you want UndoAction and RedoAction to be enabled on this component:
	 * public UndoRedo getUndoRedo () { return new MyUndoRedo (this); }
	 */

	// Printing, saving, compiling, etc.: use cookies on some appropriate node
	// and
	// use this node as the node selection.

}
